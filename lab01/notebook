
{"metadata":{"kernelspec":{"display_name":"C","language":"c","name":"c"},"language_info":{"file_extension":".c","mimetype":"text/plain","name":"c"}},"nbformat_minor":4,"nbformat":4,"cells":[{"cell_type":"markdown","source":"# Memória, Variáveis, Comunicação e Estado de um Programa\n\nHá várias possíveis estratégias para usar a memória de um computador para se realizar a comunicação entre partes dele -- por exemplo, entre duas funções -- e para se manter o **estado atual** de execução de um programa. Dentre elas, podemos destacar o uso de variáveis locais, globais e parâmetros entre funções.\n\nVamos fazer aqui um exercício nesse contexto e você será conduzido a experimentar cada uma dessas estratégias, mesmo que em algumas ocasiões não seja a forma recomendada de se desenvolver um programa.\n\n\n# Exercício do Empréstimo\n\nEm um financiamento com juros compostos e número de parcelas fixas parte-se dos seguintes parâmetros:\n* `S` - valor da primeira parcela\n* `N` - número de parcelas\n* `J` - percentual de juros mensal\n\nA primeira parcela a ser paga do financiamento é sempre igual a `S`. A partir daí é feita uma atualização mensal da parcela, em que cada nova parcela é calculada a partir da parcela do mês anterior, conforme a fórmula:\n\n> Parcela<sub>mês</sub> = Parcela<sub>mês-1</sub> * (1 + `J` / 100)\n\nO financiamento encerra quando as `N` parcelas são pagas.\n\nExemplo:\n* `S`: 200\n* `N`: 5\n* `J`: 1%\n\nParcelas do financiamento:\n`200`; `202`; `204.02`; `206.06`; `208.12`","metadata":{}},{"cell_type":"markdown","source":"## Exercício Parte 1 - Escrevendo um Programa\n\nDado o problema descrito, escreva um programa que calcule as parcelas de um empréstimo para os seguintes valores:\n* `S`: 200\n* `N`: 5\n* `J`: 1%\n\nEsses valores podem ser atribuídos na função `main`, não é necessária leitura pelo teclado. Entretanto, o programa deve ser genérico, ou seja, funcionará para qualquer outro valor atribuído às 3 variáveis.","metadata":{}},{"cell_type":"code","source":"#include <stdio.h>\n\nint main(){\n    int S = 200, N =5, i;\n    double Patual, J = 1;\n    Patual = S;\n    // printf(\"%f\",Patual);\n    for(i = 0; i < N; i++){\n        printf(\"%.2f; \",Patual);\n        Patual = Patual * (1 + J / 100);\n    }\n    return 0;\n}","metadata":{"trusted":true},"execution_count":1,"outputs":[{"name":"stdout","text":"200.00; 202.00; 204.02; 206.06; 208.12; ","output_type":"stream"}]},{"cell_type":"markdown","source":"## Exercício Parte 2 - Escrevendo um Módulo (Função)\n\nReescreva o código acima de forma que seu programa faça uso de uma função `proximaParcela` que seja responsável pelo cálculo de cada parcela X do empréstimo.\n\nUtilize as boas práticas de modularização que você aprendeu, evitando dependências do módulo com o programa em que está inserida. Considere que esta função poderia ser eventualmente reusada em outro programa e deveria ser possível fazê-lo sem que ela dependa de nada do programa em que irá se inserir.\n\nA função deve apenas calcular uma única parcela em cada chamada, portanto, ficará a cargo da função principal que chama `proximaParcela` realizar o restante do processo, para que sejam apresentadas todas as parcelas do financiamento.","metadata":{}},{"cell_type":"code","source":"#include <stdio.h>\n\ndouble proximaParcela(double parcela_atual, double juros){\n    parcela_atual = parcela_atual * (1 + juros / 100);\n    return parcela_atual;\n}\n\nint main(){\n    int S = 200;\n    double J = 1;\n\n    printf(\"%.2f\",proximaParcela(S, J));\n    return 0;\n}","metadata":{"trusted":true},"execution_count":2,"outputs":[{"name":"stdout","text":"202.00","output_type":"stream"}]},{"cell_type":"markdown","source":"## Exercício Parte 3 - Minimizando os Parâmetros\n\nNa solução anterior, você deve ter usado vários parâmetros para a comunicação entre o `main` com a função `proximaParcela`, evitando usar variáveis globais. Modifique a forma como você representa o empréstimo, de forma que a função `proximaParcela` receba sempre um único parâmetro capaz de representar todos os valores que estejam relacionados a um empréstimo.","metadata":{"tags":[]}},{"cell_type":"code","source":"#include <stdio.h>\ntypedef struct Emprestimo{\n    float s;\n    float j;\n    int n;\n    int parcela_atual;\n    float valorAtual;\n}Emprestimo;\n\n\nEmprestimo abreEmprestimo(float s, float j , int n){\n    Emprestimo novoEmprestimo;\n    novoEmprestimo.s = s;\n    novoEmprestimo.j = j;\n    novoEmprestimo.n = n;\n    novoEmprestimo.parcela_atual = 1;\n    novoEmprestimo.valorAtual = s;\n    return novoEmprestimo;\n}\n\nfloat proximaParcela(Emprestimo *emprestimoAtual){\n\n    float parcela;\n    if(emprestimoAtual->parcela_atual < emprestimoAtual->n){\n        emprestimoAtual->s = emprestimoAtual->s * (1 + emprestimoAtual->j/100);\n        emprestimoAtual->valorAtual = emprestimoAtual->s;\n    }\n    else{\n        emprestimoAtual->valorAtual = 0;\n    }\n    emprestimoAtual->parcela_atual++;\n    parcela = emprestimoAtual->valorAtual;\n    return parcela;\n}\n\nint main(){\n    int s = 200;\n    float j = 1;\n    int n=5;\n    float parcela;\n\n    Emprestimo emprestimoAtual;\n\n    emprestimoAtual = abreEmprestimo(s, j, n);\n    \n    parcela = s;\n\n    while (parcela != 0)\n    {\n        printf(\"%.2f \\n\", parcela);\n        parcela = proximaParcela(&emprestimoAtual);\n    }\n    return 0;\n}","metadata":{"trusted":true},"execution_count":3,"outputs":[{"name":"stdout","text":"200.00 \n202.00 \n204.02 \n206.06 \n208.12 \n","output_type":"stream"}]},{"cell_type":"markdown","source":"## Exercício Parte 4 - Mantendo o Estado\n\nA função que você codificou na solução anterior provavelmente não é capaz de manter o controle do que chamaremos de **estado do empréstimo**, ou seja, dados de qual a parcela corrente ou da última parcela calculada.\n\nModifique a função (módulo) `proximaParcela` acima de modo que ela seja capaz de guardar o **estado do empréstimo** por sua conta, sem que o `main` precise ficar informando este estado por parâmetros (por exemplo). Para isso serão permitidas as seguintes modificações:\n\n1. você pode desmembrar a função em mais de uma, por exemplo, uma você chama no começo do empréstimo e outra a cada parcela;\n\n2. você pode usar técnicas de uso de variáveis não recomendadas que geram dependência das funções com o programa em que ela está inserida.\n\nVocê deve organizar o código de tal maneira que o `main` informe para as funções os dados do financiamento apenas uma única vez e depois possa solicitar o cálculo da parcela subsequente sem informar tudo novamente. O ideal é que o main não tenha acesso ao modo como as funções vão representar o **estado do empréstimo**, para que toda a lógica do empréstimo fique dentro das funções.","metadata":{}},{"cell_type":"code","source":"#include <stdio.h>\n\nfloat glob_s, glob_j, parcela;\nint   glob_n, parcela_atual;\n\nvoid novoEmprestimo(float s, int n, float j) {\n    glob_s = s;\n    glob_n = n;\n    glob_j = j;\n    parcela_atual = 1;\n    parcela = s;\n}\n\nfloat proximaParcela() {\n    float retorno = parcela;\n    parcela_atual++;\n    if (parcela_atual <= glob_n)\n        parcela = parcela * (1 + glob_j / 100);\n    else\n        parcela = 0;\n    return retorno;\n}\n\nint main() {\n    int cont = 1;\n\n    novoEmprestimo(200, 5, 1);\n    float parcela = proximaParcela();\n    while (parcela > 0) {\n        printf(\"parcela %d: %3.2f\\n\", cont, parcela);\n        parcela = proximaParcela();\n        cont++;\n    }   \n    return 0;\n}","metadata":{"trusted":true},"execution_count":5,"outputs":[{"name":"stdout","text":"parcela 1: 200.00\nparcela 2: 202.00\nparcela 3: 204.02\nparcela 4: 206.06\nparcela 5: 208.12\n","output_type":"stream"}]},{"cell_type":"markdown","source":"## Exercício Parte 5 - Múltiplos Empréstimos\n\nConsidere que há múltiplos empréstimos que podem ser controlados em paralelo. A sua função `main` deve ser capaz de apresentar no console as parcelas de mais de um empréstimo de modo paralelo, mantendo um controle para cada **estado de empréstimo** separadamente. Você deve decidir qual das soluções tomará como ponto de partida, se deve modificar a função `main`, as funções de cálculo do empréstimo ou ambas para atender esse requisito da melhor forma possível.\n\nAdote uma solução compacta e generalizável, de tal modo que comporte até 100 empréstimo e, cada novo empréstimo, só exija a informação dos parâmetros de partida, sem expansão do código.\n\nPor exemplo, suponha os seguintes dois empréstimos em paralelo:\n\n### Empréstimo 1\n* `S`: 200\n* `N`: 5\n* `J`: 1%\n\n### Empréstimo 2\n* `S`: 500\n* `N`: 7\n* `J`: 2%\n\nA saída esperada é:\n~~~\nEmprestimo 1: parcela 1 eh 200.00\nEmprestimo 2: parcela 1 eh 500.00\nEmprestimo 1: parcela 2 eh 202.00\nEmprestimo 2: parcela 2 eh 510.00\nEmprestimo 1: parcela 3 eh 204.02\nEmprestimo 2: parcela 3 eh 520.20\nEmprestimo 1: parcela 4 eh 206.06\nEmprestimo 2: parcela 4 eh 530.60\nEmprestimo 1: parcela 5 eh 208.12\nEmprestimo 2: parcela 5 eh 541.22\nEmprestimo 2: parcela 6 eh 552.04\nEmprestimo 2: parcela 7 eh 563.08\n~~~\n\nO exemplo mostra dois empréstimos, mas a estrutura deve ser genérica o suficiente para controlar N empréstimos em paralelo (até o limite de 100).\n\nO seu programa deve apresentar o exemplo acima como teste.","metadata":{}},{"cell_type":"code","source":"#include <stdio.h>\n#define MAX 100\n\ntypedef struct Emprestimo{\n    float s;\n    float j;\n    int n;\n    int parcela_atual;\n    float valorAtual;\n    int numero_emp;\n    int terminado;\n}Emprestimo;\n\nstruct Emprestimo arr_emprestimo[MAX];\n\nEmprestimo abreEmprestimo(float s, float j , int n, int cont){\n    Emprestimo novoEmprestimo;\n    novoEmprestimo.s = s;\n    novoEmprestimo.j = j;\n    novoEmprestimo.n = n;\n    novoEmprestimo.parcela_atual = 1;\n    novoEmprestimo.valorAtual = s;\n    novoEmprestimo.numero_emp = cont + 1;\n    novoEmprestimo.terminado = 0;\n    return novoEmprestimo;\n}\n\nfloat proximaParcela(Emprestimo *emprestimoAtual){\n\n    float parcela;\n    if(emprestimoAtual->parcela_atual == 1 ){\n        emprestimoAtual->parcela_atual++;\n        return emprestimoAtual->s;\n    }\n    else if(emprestimoAtual->parcela_atual <= emprestimoAtual->n){\n        emprestimoAtual->s = emprestimoAtual->s * (1 + emprestimoAtual->j/100);\n        emprestimoAtual->valorAtual = emprestimoAtual->s;\n    }\n    else{\n        emprestimoAtual->valorAtual = 0;\n    }\n\n    if (emprestimoAtual->parcela_atual == emprestimoAtual->n){\n        emprestimoAtual->terminado = 1;\n    }\n    emprestimoAtual->parcela_atual++;\n    parcela = emprestimoAtual->valorAtual;\n    return parcela;\n}\n\nint terminou(Emprestimo arr_emprestimo[MAX]){\n    int i = 0;\n    for(i = 0; i < MAX; i++){\n        if(arr_emprestimo[i].terminado == 0 ){\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main(){\n    //variaveis  necessarias para o caso geral\n    // float s, j;\n    // int n, cont = 0; \n    int i;\n    float parcela;\n\n    for(i=0; i < MAX; i++){\n        arr_emprestimo[i].s = 0;\n        arr_emprestimo[i].j = 0;\n        arr_emprestimo[i].n = 0;\n        arr_emprestimo[i].terminado = 1;\n    }\n\n\n    // while( scanf(\"%f\", &s) != EOF){\n    //     scanf(\"%d\", &n);\n    //     scanf(\"%f\", &j);\n    //     arr_emprestimo[cont] = abreEmprestimo(s, j, n, cont);\n    //     cont ++;\n    // }\n\n    arr_emprestimo[0] = abreEmprestimo(200, 1, 5, 0);\n    arr_emprestimo[1] = abreEmprestimo(500, 2, 7, 1);\n\n    i = 0;\n    while (terminou(arr_emprestimo) != 1)\n    {\n        parcela = proximaParcela(&arr_emprestimo[i]);\n        if (parcela != 0){\n            printf(\"Emprestimo %d: parcela %d eh %.2f\\n\",arr_emprestimo[i].numero_emp, arr_emprestimo[i].parcela_atual - 1, parcela);\n        }\n        \n        i++;\n        if(i == 100 || arr_emprestimo[i].s == 0){\n            i = 0;\n        }\n    }\n    return 0;\n}","metadata":{"trusted":true},"execution_count":4,"outputs":[{"name":"stdout","text":"Emprestimo 1: parcela 1 eh 200.00\nEmprestimo 2: parcela 1 eh 500.00\nEmprestimo 1: parcela 2 eh 202.00\nEmprestimo 2: parcela 2 eh 510.00\nEmprestimo 1: parcela 3 eh 204.02\nEmprestimo 2: parcela 3 eh 520.20\nEmprestimo 1: parcela 4 eh 206.06\nEmprestimo 2: parcela 4 eh 530.60\nEmprestimo 1: parcela 5 eh 208.12\nEmprestimo 2: parcela 5 eh 541.22\nEmprestimo 2: parcela 6 eh 552.04\nEmprestimo 2: parcela 7 eh 563.08\n","output_type":"stream"}]},{"cell_type":"code","source":"","metadata":{},"execution_count":null,"outputs":[]}]}
